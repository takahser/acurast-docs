"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[380],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>_});var r=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,s=function(e,t){if(null==e)return{};var n,r,s={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,s=e.mdxType,a=e.originalType,p=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=l(n),_=s,u=m["".concat(p,".").concat(_)]||m[_]||d[_]||a;return n?r.createElement(u,i(i({ref:t},c),{},{components:n})):r.createElement(u,i({ref:t},c))}));function _(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var a=n.length,i=new Array(a);i[0]=m;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:s,i[1]=o;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6499:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var r=n(7462),s=(n(7294),n(3905));const a={title:"Tezos",slug:"/integrations/tezos"},i="Tezos Integration",o={unversionedId:"integrations/tezos",id:"integrations/tezos",title:"Tezos",description:"Acurast Transmitters can directly communicate with Tezos smart contracts as the required secp256r1 is natively available on Tezos.",source:"@site/docs/integrations/tezos.mdx",sourceDirName:"integrations",slug:"/integrations/tezos",permalink:"/integrations/tezos",draft:!1,editUrl:"https://github.com/acurast/acurast-docs/docs/integrations/tezos.mdx",tags:[],version:"current",frontMatter:{title:"Tezos",slug:"/integrations/tezos"},sidebar:"docs",previous:{title:"Substrate With WASM",permalink:"/integrations/substrate-wasm"}},p={},l=[{value:"Example Contract",id:"example-contract",level:2}],c={toc:l};function d(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"tezos-integration"},"Tezos Integration"),(0,s.kt)("p",null,"Acurast Transmitters can directly communicate with Tezos smart contracts as the required secp256r1 is natively available on Tezos."),(0,s.kt)("h2",{id:"example-contract"},"Example Contract"),(0,s.kt)("p",null,"The following Tezos smart contract in SmartPy is an example of a contract that receives price points from Acurast Transmitters."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-py"},'import smartpy as sp\n\nfrom contracts.oracle.job_scheduler import Fulfill\n\nimport utils.constants as Constants\nimport utils.error_codes as Errors\n\n\nclass Response:\n    def get_type():\n        """The response type used for the price oracle that uses the generic data\n        transmitter.\n        """\n        return sp.TRecord(\n            timestamp=sp.TNat, prices=sp.TList(ResponsePriceEntry.get_type())\n        ).layout(("timestamp", "prices"))\n\n    def make(timestamp, prices):\n        """Courtesy function typing a record to Response.get_type()."""\n        return sp.set_type_expr(\n            sp.record(timestamp=timestamp, prices=prices), Response.get_type()\n        )\n\n\nclass ResponsePriceEntry:\n    def get_type():\n        """A single price entry response type used for the price oracle that uses the\n        generic data transmitter.\n        """\n        return sp.TRecord(symbol=sp.TString, price=sp.TNat).layout(("symbol", "price"))\n\n\nclass ValidPriceEntry:\n    def get_type():\n        """A valid single price entry type stored in the smart contract in order to do\n        price aggregation.\n        """\n        return sp.TRecord(valid_respondants=sp.TSet(sp.TAddress), price=sp.TNat).layout(\n            ("valid_respondants", "price")\n        )\n\n    def make(valid_respondants, price):\n        """Courtesy function typing a record to ValidPriceEntry.get_type()."""\n        return sp.set_type_expr(\n            sp.record(valid_respondants=valid_respondants, price=price),\n            ValidPriceEntry.get_type(),\n        )\n\n\nclass StoragePriceEntry:\n    """A single storage price entry type stored in the prices big map of the smart contract."""\n\n    def get_type():\n        return sp.TRecord(last_epoch=sp.TNat, price=sp.TNat).layout(\n            ("last_epoch", "price")\n        )\n\n    def make(last_epoch, price):\n        """Courtesy function typing a record to StoragePriceEntry.get_type()."""\n        return sp.set_type_expr(\n            sp.record(last_epoch=last_epoch, price=price), StoragePriceEntry.get_type()\n        )\n\n\nclass PriceOracle(sp.Contract):\n    """The generic price oracle accepts prices from the set sources and set script.\n    The change in price logic is controlled by the validation and aggregation lambdas.\n    This version of the oracle uses the onchain views to return prices.\n    Only the administrator is allowed to change the script and sources.\n    """\n\n    def __init__(self, administrator):\n        self.init(\n            prices=sp.big_map(tkey=sp.TString, tvalue=StoragePriceEntry.get_type()),\n            aggregation_lambda=sp.lambda_michelson(\n                "{ CDR; UNPAIR; PUSH nat 0; DUP 3; COMPARE; GT; IF {} { PUSH int 501; FAILWITH }; DUP; PUSH nat 0; COMPARE; EQ; IF { PUSH bool True } { SWAP; DUP; DUG 2; SWAP; DUP; DUG 2; SUB; ABS; PUSH nat 4; DUP 3; LSR; COMPARE; GT }; IF { DROP } { PUSH int 0; DIG 2; DUP 3; SUB; COMPARE; GT; IF { DUP; PUSH nat 4; SWAP; LSR; SWAP; SUB; ISNAT; IF_NONE { PUSH int 668; FAILWITH } {} } { DUP; PUSH nat 4; SWAP; LSR; ADD } } }",\n                sp.TPair(sp.TString, sp.TPair(sp.TNat, sp.TNat)),\n                sp.TNat,\n            ),\n            validation_lambda=sp.lambda_michelson(\n                "{ CDR; UNPAIR; SWAP; DUP; DUG 2; SWAP; SUB; ABS; PUSH nat 10; DIG 2; LSR; COMPARE; GE }",\n                sp.TPair(sp.TString, sp.TPair(sp.TNat, sp.TNat)),\n                sp.TBool,\n            ),\n            response_threshold=sp.nat(3),\n            validity_window_in_epochs=sp.nat(4),\n            valid_script=sp.bytes(\n                "0x697066733a2f2f516d624c705353554e3473596a773368594577624c743762534a58734635476150507074476a776f59787363414a"\n            ),\n            valid_prices=sp.map(tkey=sp.TString, tvalue=ValidPriceEntry.get_type()),\n            valid_epoch=sp.nat(0),\n            contract_outside_cache_no=sp.nat(0),\n            valid_sources=sp.set(\n                [\n                    sp.address("tz3AcurastTransmitterAddress"),\n                    sp.address("tz3AcurastTransmitterAddress"),\n                    sp.address("tz3AcurastTransmitterAddress"),\n                    sp.address("tz3AcurastTransmitterAddress"),\n                    sp.address("tz3AcurastTransmitterAddress"),\n                ]\n            ),\n            administrator=administrator,\n            proposed_administrator=administrator,\n        )\n\n    @sp.entry_point(check_no_incoming_transfer=True)\n    def touch(self):\n        """Entrypoint used to cache the smart contract if it is not cached. The entrypoint\n        updates the counter which stores how many times the contract was outside the cache.\n        In reality this entrypoint can be called by anyone, therefore the counter serves\n        as an approximation and not the real value.\n        """\n        self.data.contract_outside_cache_no += 1\n\n    @sp.entry_point(check_no_incoming_transfer=True)\n    def set_valid_script(self, script):\n        """Entrypoint used by the admin to set the valid script.\n        Only admin is allowed to call this entrypoint.\n        """\n        sp.verify(sp.sender == self.data.administrator, message=Errors.NOT_ADMIN)\n        self.data.valid_script = script\n\n    @sp.entry_point(check_no_incoming_transfer=True)\n    def propose_administrator(self, proposed_administrator):\n        """Entrypoint used by the admin to set the new admin. Only admin is allowed to call this entrypoint.\n        """\n        sp.verify(sp.sender==self.data.administrator, message=Errors.NOT_ADMIN)\n        self.data.proposed_administrator = proposed_administrator\n\n    @sp.entry_point(check_no_incoming_transfer=True)\n    def set_administrator(self):\n        """Entrypoint used by the proposed admin to set itself as admin.\n        """\n        sp.verify(sp.sender==self.data.proposed_administrator, message=Errors.NOT_ADMIN)\n        self.data.administrator = self.data.proposed_administrator\n\n    @sp.entry_point(check_no_incoming_transfer=True)\n    def update_threshold(self, threshold):\n        """Entrypoint used by the admin to set the threshold for the number of valid responses.\n        """\n        sp.verify(sp.sender==self.data.administrator, message=Errors.NOT_ADMIN)\n        self.data.response_threshold = threshold\n\n    @sp.entry_point(check_no_incoming_transfer=True)\n    def add_valid_source(self, source):\n        """Entrypoint used by the admin to add a new source.\n        Only admin is allowed to call this entrypoint.\n        """\n        sp.verify(sp.sender == self.data.administrator, message=Errors.NOT_ADMIN)\n        self.data.valid_sources.add(source)\n\n    @sp.entry_point(check_no_incoming_transfer=True)\n    def remove_valid_source(self, source):\n        """Entrypoint used by the admin to remove an existing source.\n        Only admin is allowed to call this entrypoint.\n        """\n        sp.verify(sp.sender == self.data.administrator, message=Errors.NOT_ADMIN)\n        self.data.valid_sources.remove(source)\n\n    @sp.entry_point(check_no_incoming_transfer=True)\n    def update_aggregation_lambda(self, _lambda):\n        """Entrypoint used by the admin to update the aggregation lambda.\n        Only admin is allowed to call this entrypoint.\n        """\n        sp.verify(sp.sender == self.data.administrator, message=Errors.NOT_ADMIN)\n\n        sp.set_type(\n            _lambda,\n            sp.TLambda(sp.TPair(sp.TString, sp.TPair(sp.TNat, sp.TNat)), sp.TNat),\n        )\n        self.data.aggregation_lambda = _lambda\n\n    @sp.entry_point(check_no_incoming_transfer=True)\n    def update_validation_lambda(self, _lambda):\n        """Entrypoint used by the admin to update the validation lambda.\n        Only admin is allowed to call this entrypoint.\n        """\n        sp.verify(sp.sender == self.data.administrator, message=Errors.NOT_ADMIN)\n\n        sp.set_type(\n            _lambda,\n            sp.TLambda(sp.TPair(sp.TString, sp.TPair(sp.TNat, sp.TNat)), sp.TBool),\n        )\n        self.data.validation_lambda = _lambda\n\n    @sp.entry_point(check_no_incoming_transfer=True)\n    def fulfill(self, fulfill):\n        """The fulfill entrypoint is called by the data transmitter directly. It\'s your\n        responsibility to make it as efficient as possible (it has a gas and storage limit\n        of 11000). While the sp.sender of this entrypoint will always be the JobScheduler\n        above, the sp.source will always be the data transmitter. It\'s your responsibility\n        to check that you are receivng the data from the right source. This implementation\n        does also aggregate multiple respondants, hence the slightly more complex\n        implementation.\n        This entrypoint checks if the source and script is valid, then if the answer fits\n        in the current epoch, comes from a new source and matches with some minor precision\n        margin the value set by a previous source the response is counted as +1. If the\n        response counter reaches the threshold the price in storage is set and ready to be\n        used by the get_price view.\n        """\n        sp.set_type(fulfill, Fulfill.get_type())\n\n        sp.verify(\n            self.data.valid_script == fulfill.script, message=Errors.INVALID_SCRIPT\n        )\n        sp.verify(\n            self.data.valid_sources.contains(sp.source), message=Errors.INVALID_SOURCE\n        )\n\n        response = sp.local(\n            "response", sp.unpack(fulfill.payload, Response.get_type()).open_some()\n        )\n        current_epoch = sp.local(\n            "current_epoch", response.value.timestamp // Constants.ORACLE_EPOCH_INTERVAL\n        )\n        sp.verify(\n            current_epoch.value\n            == sp.as_nat(sp.now - sp.timestamp(0)) // Constants.ORACLE_EPOCH_INTERVAL,\n            message=Errors.NOT_IN_EPOCH,\n        )\n\n        with sp.if_((current_epoch.value > self.data.valid_epoch)):\n            self.data.valid_prices = sp.map({})\n            self.data.valid_epoch = current_epoch.value\n\n        validation_lambda = sp.local("validation_lambda", self.data.validation_lambda)\n        aggregation_lambda = sp.local("aggregation_lambda", self.data.aggregation_lambda)\n        with sp.for_("price", response.value.prices) as price:\n            with sp.if_(~self.data.valid_prices.contains(price.symbol)):\n                self.data.valid_prices[price.symbol] = ValidPriceEntry.make(\n                    sp.set(), price.price\n                )\n            valid_price = sp.local(\n                "valid_price", self.data.valid_prices[price.symbol].price\n            )\n            validation_lambda_param = sp.pair(\n                price.symbol, sp.pair(price.price, valid_price.value)\n            )\n            with sp.if_(validation_lambda.value(validation_lambda_param)):\n                self.data.valid_prices[price.symbol].valid_respondants.add(sp.source)\n                with sp.if_(\n                    sp.len(self.data.valid_prices[price.symbol].valid_respondants)\n                    >= self.data.response_threshold\n                ):\n                    with sp.if_(~self.data.prices.contains(price.symbol)):\n                        self.data.prices[price.symbol] = StoragePriceEntry.make(\n                            current_epoch.value, valid_price.value\n                        )\n                    with sp.else_():\n                        last_price = sp.local("last_price", self.data.prices[price.symbol])\n                        with sp.if_(last_price.value.last_epoch < current_epoch.value):\n                            aggregation_lambda_param = sp.pair(\n                                price.symbol,\n                                sp.pair(\n                                    last_price.value.price, valid_price.value\n                                ),\n                            )\n                            self.data.prices[price.symbol] = StoragePriceEntry.make(\n                                current_epoch.value,\n                                aggregation_lambda.value(aggregation_lambda_param),\n                            )\n\n    @sp.onchain_view()\n    def get_price(self, symbol):\n        """Onchain view used to read the price out of storage. The onchain view takes the\n        symbol as parameter and reads the respective entry from storage to then return it.\n        The price is only returned if it is not older than the validity window set in\n        storage expressed it interval integer.\n        """\n        current_epoch = (\n            sp.as_nat(sp.now - sp.timestamp(0)) // Constants.ORACLE_EPOCH_INTERVAL\n        )\n        sp.verify(\n            self.data.prices[symbol].last_epoch\n            > sp.as_nat(current_epoch - self.data.validity_window_in_epochs),\n            message=Errors.PRICE_TOO_OLD,\n        )\n        sp.verify(self.data.prices[symbol].price > 0, message=Errors.CANNOT_BE_ZERO)\n        sp.result(self.data.prices[symbol].price)\n')))}d.isMDXComponent=!0}}]);